{
  "api/Surfer.html": {
    "href": "api/Surfer.html",
    "title": "Namespace Surfer | Copyright © 2021 ATStudio",
    "keywords": "Namespace Surfer Classes SUIndicatorCamInfo SUIndicatorData SUIndicatorDataDrawer SUIndicatorInfo SUIndicatorLink SUIndicatorsManager SUToolsMenu Structs SUIndicatorEventData Interfaces ISUIndicatorStateHandler Enums SUIndicatorData.CameraType_ID SUIndicatorData.SUIndicatorDistanceState_ID SUIndicatorData.Type_ID SUIndicatorState_ID"
  },
  "api/Surfer.ISUIndicatorStateHandler.html": {
    "href": "api/Surfer.ISUIndicatorStateHandler.html",
    "title": "Interface ISUIndicatorStateHandler | Copyright © 2021 ATStudio",
    "keywords": "Interface ISUIndicatorStateHandler Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public interface ISUIndicatorStateHandler Methods OnIndicatorStateUpdate(SUIndicatorEventData) Declaration void OnIndicatorStateUpdate(SUIndicatorEventData eventData) Parameters Type Name Description SUIndicatorEventData eventData"
  },
  "api/Surfer.SUIndicatorCamInfo.html": {
    "href": "api/Surfer.SUIndicatorCamInfo.html",
    "title": "Class SUIndicatorCamInfo | Copyright © 2021 ATStudio",
    "keywords": "Class SUIndicatorCamInfo Inheritance Object SUIndicatorCamInfo Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public class SUIndicatorCamInfo Properties Cam Declaration public Camera Cam { get; set; } Property Value Type Description Camera CamCanvas Declaration public Canvas CamCanvas { get; set; } Property Value Type Description Canvas CamCanvasRect Declaration public RectTransform CamCanvasRect { get; set; } Property Value Type Description RectTransform Objects Declaration public Dictionary<RectTransform, SUIndicatorInfo> Objects { get; set; } Property Value Type Description Dictionary < RectTransform , SUIndicatorInfo >"
  },
  "api/Surfer.SUIndicatorData.CameraType_ID.html": {
    "href": "api/Surfer.SUIndicatorData.CameraType_ID.html",
    "title": "Enum SUIndicatorData.CameraType_ID | Copyright © 2021 ATStudio",
    "keywords": "Enum SUIndicatorData.CameraType_ID Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public enum CameraType_ID Fields Name Description Custom ExceptMain Main"
  },
  "api/Surfer.SUIndicatorData.html": {
    "href": "api/Surfer.SUIndicatorData.html",
    "title": "Class SUIndicatorData | Copyright © 2021 ATStudio",
    "keywords": "Class SUIndicatorData Inheritance Object SUIndicatorData Namespace : Surfer Assembly : cs.temp.dll.dll Syntax [Serializable] public class SUIndicatorData Properties AngleOffset Declaration public float AngleOffset { get; } Property Value Type Description Single Cameras Declaration public List<Camera> Cameras { get; } Property Value Type Description List < Camera > CanCheckDistance Declaration public bool CanCheckDistance { get; } Property Value Type Description Boolean CustomTag Declaration public string CustomTag { get; } Property Value Type Description String DistanceStates Declaration public List<SUIndicatorData.SUIndicatorDistanceState_ID> DistanceStates { get; set; } Property Value Type Description List < SUIndicatorData.SUIndicatorDistanceState_ID > DistanceTargets Declaration public List<Transform> DistanceTargets { get; } Property Value Type Description List < Transform > IsOffScreenType Declaration public bool IsOffScreenType { get; } Property Value Type Description Boolean IsOnScreenType Declaration public bool IsOnScreenType { get; } Property Value Type Description Boolean Prefab Declaration public GameObject Prefab { get; } Property Value Type Description GameObject Target Declaration public Transform Target { get; } Property Value Type Description Transform Type Declaration public SUIndicatorData.Type_ID Type { get; } Property Value Type Description SUIndicatorData.Type_ID Methods StartFollow() Declaration public void StartFollow() StopFollow() Declaration public void StopFollow() StopFollow(Camera) Declaration public void StopFollow(Camera cam) Parameters Type Name Description Camera cam"
  },
  "api/Surfer.SUIndicatorData.SUIndicatorDistanceState_ID.html": {
    "href": "api/Surfer.SUIndicatorData.SUIndicatorDistanceState_ID.html",
    "title": "Enum SUIndicatorData.SUIndicatorDistanceState_ID | Copyright © 2021 ATStudio",
    "keywords": "Enum SUIndicatorData.SUIndicatorDistanceState_ID Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public enum SUIndicatorDistanceState_ID Fields Name Description Close NotClose"
  },
  "api/Surfer.SUIndicatorData.Type_ID.html": {
    "href": "api/Surfer.SUIndicatorData.Type_ID.html",
    "title": "Enum SUIndicatorData.Type_ID | Copyright © 2021 ATStudio",
    "keywords": "Enum SUIndicatorData.Type_ID Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public enum Type_ID Fields Name Description Both Off On"
  },
  "api/Surfer.SUIndicatorDataDrawer.html": {
    "href": "api/Surfer.SUIndicatorDataDrawer.html",
    "title": "Class SUIndicatorDataDrawer | Copyright © 2021 ATStudio",
    "keywords": "Class SUIndicatorDataDrawer Inheritance Object SUIndicatorDataDrawer Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public class SUIndicatorDataDrawer : PropertyDrawer Methods GetPropertyHeight(SerializedProperty, GUIContent) Declaration public override float GetPropertyHeight(SerializedProperty property, GUIContent label) Parameters Type Name Description SerializedProperty property GUIContent label Returns Type Description Single OnGUI(Rect, SerializedProperty, GUIContent) Declaration public override void OnGUI(Rect position, SerializedProperty property, GUIContent label) Parameters Type Name Description Rect position SerializedProperty property GUIContent label"
  },
  "api/Surfer.SUIndicatorEventData.html": {
    "href": "api/Surfer.SUIndicatorEventData.html",
    "title": "Struct SUIndicatorEventData | Copyright © 2021 ATStudio",
    "keywords": "Struct SUIndicatorEventData Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public struct SUIndicatorEventData Constructors SUIndicatorEventData(SUIndicatorInfo, SUIndicatorCamInfo) Declaration public SUIndicatorEventData(SUIndicatorInfo info, SUIndicatorCamInfo camInfo) Parameters Type Name Description SUIndicatorInfo info SUIndicatorCamInfo camInfo Fields CamInfo Declaration public SUIndicatorCamInfo CamInfo Field Value Type Description SUIndicatorCamInfo Info Declaration public SUIndicatorInfo Info Field Value Type Description SUIndicatorInfo"
  },
  "api/Surfer.SUIndicatorInfo.html": {
    "href": "api/Surfer.SUIndicatorInfo.html",
    "title": "Class SUIndicatorInfo | Copyright © 2021 ATStudio",
    "keywords": "Class SUIndicatorInfo Inheritance Object SUIndicatorInfo Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public class SUIndicatorInfo Constructors SUIndicatorInfo(SUIndicatorState_ID, SUIndicatorData, RectTransform) Declaration public SUIndicatorInfo(SUIndicatorState_ID state, SUIndicatorData data, RectTransform obj) Parameters Type Name Description SUIndicatorState_ID state SUIndicatorData data RectTransform obj Properties Data Declaration public SUIndicatorData Data { get; } Property Value Type Description SUIndicatorData Object Declaration public RectTransform Object { get; } Property Value Type Description RectTransform State Declaration public SUIndicatorState_ID State { get; set; } Property Value Type Description SUIndicatorState_ID"
  },
  "api/Surfer.SUIndicatorLink.html": {
    "href": "api/Surfer.SUIndicatorLink.html",
    "title": "Class SUIndicatorLink | Copyright © 2021 ATStudio",
    "keywords": "Class SUIndicatorLink Inheritance Object SUIndicatorLink Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public class SUIndicatorLink : MonoBehaviour"
  },
  "api/Surfer.SUIndicatorsManager.html": {
    "href": "api/Surfer.SUIndicatorsManager.html",
    "title": "Class SUIndicatorsManager | Copyright © 2021 ATStudio",
    "keywords": "Class SUIndicatorsManager Inheritance Object SUIndicatorsManager Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public class SUIndicatorsManager : MonoBehaviour Properties I Declaration public static SUIndicatorsManager I { get; set; } Property Value Type Description SUIndicatorsManager Methods GetIndicatorsByCustomTag(String) Get all the infos and camInfos about Indicators with a specific custom tag (WARNING: it creates a new list every time, so cache it!) Declaration public List<SUIndicatorEventData> GetIndicatorsByCustomTag(string customTag) Parameters Type Name Description String customTag Returns Type Description List < SUIndicatorEventData > StartFollow(SUIndicatorData) Declaration public void StartFollow(SUIndicatorData data) Parameters Type Name Description SUIndicatorData data StopFollow(Camera) Declaration public void StopFollow(Camera cam) Parameters Type Name Description Camera cam StopFollow(SUIndicatorData) Declaration public void StopFollow(SUIndicatorData data) Parameters Type Name Description SUIndicatorData data StopFollow(SUIndicatorData, Camera) Declaration public void StopFollow(SUIndicatorData data, Camera cam) Parameters Type Name Description SUIndicatorData data Camera cam StopFollow(String) Declaration public void StopFollow(string customTag) Parameters Type Name Description String customTag"
  },
  "api/Surfer.SUIndicatorState_ID.html": {
    "href": "api/Surfer.SUIndicatorState_ID.html",
    "title": "Enum SUIndicatorState_ID | Copyright © 2021 ATStudio",
    "keywords": "Enum SUIndicatorState_ID Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public enum SUIndicatorState_ID Fields Name Description FollowingOffScreen FollowingOnScreen Standby"
  },
  "api/Surfer.SUToolsMenu.html": {
    "href": "api/Surfer.SUToolsMenu.html",
    "title": "Class SUToolsMenu | Copyright © 2021 ATStudio",
    "keywords": "Class SUToolsMenu Inheritance Object SUToolsMenu Namespace : Surfer Assembly : cs.temp.dll.dll Syntax public class SUToolsMenu : EditorWindow"
  },
  "changelog.html": {
    "href": "changelog.html",
    "title": "Changelog | Copyright © 2021 ATStudio",
    "keywords": "Changelog All notable changes to Surfer will be documented in this page. [2.4] - 2021-07-05 Surfer 2.4 is out! Added Selection_Indicator element type to \"indicate\" the current selected UI object with some custom animations! Changed History Focus logic and behavior Fixed Loading/Unloading scene events null ref Rarely, the custom reactions / custom conditions inspector was not saving the list immediately [2.3] - 2021-06-07 Surfer 2.3 is out! Added 8 New Fast Reactions : PlayerPrefs_SetInt, PlayerPrefs_SetFloat, PlayerPrefs_SetString, PlayerPrefs_DeleteKey, PlayerPrefs_DeleteAll, Animator_PlayState, Animator_Stop, Animations_StopCharTweener 8 New Fast Conditions : PlayerPrefs_IsIntEqualTo, PlayerPrefs_IsIntLowerThan, PlayerPrefs_IsIntGreaterThan, PlayerPrefs_IsFloatEqualTo, PlayerPrefs_IsFloatLowerThan, PlayerPrefs_IsFloatGreaterThan, PlayerPrefs_IsStringEqualTo, PlayerPrefs_StringContains, PlayerPrefs_HasKey, Slider_OverallVolume element type to easily manage the overall game audio with a Slider! BuildVersion_Text element type to easily show the version of the build/game on a text ! Delete Slider Volume Key button in Surfer Settings : to use only if the overall game audio volume is first managed by Surfer and then should be managed by another plugin (erase Surfer responsibility) CharTweener integration : easily animated your TextMeshPro text with this package (only found on GitHub) with these 11 animations : SplitIn, SplitOut, Wave, WaveLoop, Shaking, JumpIn, JumpOut, JumpInFull, JumpOutFull, LeftToRight, RightToLeft Fixed Surfer Scriptable Object access at runtime ( especially used for Elements types like Loading_Image and Loading_Text ) [2.2] - 2021-06-01 Fixed Editor API Error when building [2.2] - 2021-05-30 Surfer 2.2 is out ! Added New Online Manual and API ! \"If Conditions False\" Inspector Tab to run reactions when conditions fail! 5 New Fast Conditions : DateTime_IsDay, DateTime_IsMonth, DateTime_IsYear, DateTime_IsChristmas, DateTime_IsHalloween 9 New Fast Reactions : Application_OpenURL, Cursor_SetIcon, Cursor_SetIconCentered, Cursor_SetDefaultIcon, Transform_SetSizeDelta, Canvas_BringToFront, Canvas_SendToBack, UIGenerics_EnableClickConstraint, UIGenerics_DisableClickConstraint Tooltip_State type to create Tooltip with 1 click! DragLeft_State,DragRight_State, DragUp_State, DragDown_State types to create Draggable SideMenus with 1 click! AnchoredPosition inspector animation! Custom Events to let SUElement handle events of custom developer logic! Custom Reactions to run custom programmer reactions! IsStackable value to stack opening calls of a state! PlayerID value to support Local Multiplayer games with multiple independent players UIs! Loading_Text element type to easily show loading progress of a scene in a TextMeshPro! Loading_Image element type to easily show loading progress of a scene in a Filled Image! Changed History Focus logic and behavior [2.1] - 2021-05-07 Surfer 2.1 is out ! Added 11 Inspector Events : ScrollRect_OnReachedTop, ScrollRect_OnReachedBottom, ScrollRect_OnReachedLeft, ScrollRect_OnReachedRight, ScrollRect_OnNotReachedAnySide, Dropdown_OnOptionSelected, Dropdown_OnFirstOptionSelected, Slider_OnGreaterThan, Slider_OnLowerThan, Slider_OnMax, Slider_OnMin 13 Inspector Conditions : Application_IsLanguage, Application_IsNotLanguage, Application_IsPlatform, Application_IsNotPlatform, Application_IsMobileDevice, Application_IsNotMobileDevice, Application_IsConsolePlatform, Application_IsNotConsolePlatform, Slider_IsMin, Slider_IsMax, Slider_IsGreaterThan, Slider_IsLowerThan, Dropdown_IsSelected, 3 Inspector Reactions : Image_SetSprite, Dropdown_SelectOption, Slider_SetValue [2.0] - 2021-04-29 Surfer 2.0 is out! Surfer becomes easier and faster! Added SUElement component to manager every ui object. 20+ inspector events added 20+ easy inspector conditions added 20+ easy inspector reactions added"
  },
  "index.html": {
    "href": "index.html",
    "title": "Surfer | Copyright © 2021 ATStudio",
    "keywords": "Surfer Surfer is a UI Manager Tool that allows you to manage, control and jumpstart your UI flow easily and fast. It is intended to be a powerful, flexible and modular All-in-One tool to use in every kind of project from mobile to console, from single-player to multiplayer , from hypercasual to JRPG. Designers and artists can easily build the entire UI flow directly from the inspector whereas programmers can use the API to handle or extend the functionality, mechanics and callbacks of Surfer. To get started, see the Installation and the First Scene Panel section ."
  },
  "limitations.html": {
    "href": "limitations.html",
    "title": "Limitations | Copyright © 2021 ATStudio",
    "keywords": "Limitations Current known Surfer limitations : If a UI object is persistent ( is not destroyed when a new scene is loaded ) the SUElement Scene events like MySceneLoaded , MySceneLoading , MySceneUnloading , MySceneUnloaded , MySceneActivated , MySceneDeactivated don't work : use events like Awake or Start whenever possible. Selection Indicators don't work when the selected object under a Canvas is a Sprite or a Mesh Selection Indicators always render in front of the selected UI object , not behind."
  },
  "manual/Bolt.html": {
    "href": "manual/Bolt.html",
    "title": "Bolt | Copyright © 2021 ATStudio",
    "keywords": "Bolt Let’s see how to use a Surfer Action (OpenState for example) with Bolt. What we have to do in our graph is : -Use the Unit Surfer.OpenState -Get the Instance of the Surfer Singleton in order to have a target object as a caller -Add a NULL unit to CustomData if we don’t pass any our custom variable to the event/action (remember : customData is params ) Like this Event Listener DISCLAIMER : The following logic will be deprecated in the next updates in favour of Custom Surfer Units In order to receive a StateEvent in Bolt we must do as follows : add and setup the component SUStateEvent to the scene object that should receive the event in the Bolt graph open the SUStateEvent script and uncomment all the section related to Bolt (the ones that says “//Uncomment below if you are using Bolt!” ( the same for the script SUSceneEvent if you want to receive scene events ) Then, in the graph of the object, add a CustomEvent unit , insert the name related the event you want to listen to ( “OnEnter” or “OnExit” ) and run the logic you want."
  },
  "manual/CharTweener.html": {
    "href": "manual/CharTweener.html",
    "title": "CharTweener | Copyright © 2021 ATStudio",
    "keywords": "CharTweener If you're using the package CharTweener ( available on GitHub ) to animate TextMeshPro UI texts, to use it with a Surfer SUElement go to Unity->Preferences->Surfer and select it under the section Integrations . Then, select Save and Recompile and wait Unity to recompile. Now , you can animate your TextMeshPro UI text in a SUElement under the Animated! reaction list."
  },
  "manual/Click button.html": {
    "href": "manual/Click button.html",
    "title": "Click and Open | Copyright © 2021 ATStudio",
    "keywords": "Click and Open In order to simply trigger an OpenState action with a click , we must : Add SUElement component to a UI object like a Button Add the UIGeneric/OnClick event Add the OpenState action Like this:"
  },
  "manual/Close Mode.html": {
    "href": "manual/Close Mode.html",
    "title": "Close mode | Copyright © 2021 ATStudio",
    "keywords": "Close mode Other than opening a state, we can even close it. Normally , we can do it manually by calling a classic Surfer action by selecting Close State as a mode. But automatic is better than manually. The Close Mode of a state, it automatically closes all the states specified without having the developer closing manually all of them. Example : We have two siblings Tab Panels, Tab1 and Tab2. When one of them is open, the other one should be closed. By doing it manually, we would have to call 4 actions : OpenState Tab1 and CloseState Tab2 , or OpenState Tab2 and CloseState Tab1. By using Close Mode , if we choose Siblings as mode, the moment we call OpenState Tab1, the CloseState Tab2 action will be automatically triggered and viceversa. Anyway, this mode should be set directly in the SUElement component of each state, like : And for example, other than reacting to its MyStateEnter event, every state can also react accordingly to its MyStateExit event by moving out of camera view, like : In the Demo folder of the package, we can see this exact behaviour in the DemoScene called Tabs"
  },
  "manual/Custom Conditions.html": {
    "href": "manual/Custom Conditions.html",
    "title": "Custom Conditions | Copyright © 2021 ATStudio",
    "keywords": "Custom Conditions Let’s see how we can add Custom conditions to the inspector list of the SUElement . What we have to do is to open the script ConditionChecks that we can find in the Condition folder. Then we must simply add a new entry to the dictionary called “All”. The KeyValuePair entry is structured in this way : Key : is a string use to identify the condition in the inspector (if you change it , all the references in all the inspector will be lost) Value : is a combination of a string and a function. The string is the name/path of the condition that you will see written in the Inspector ( you can change it as many times as you want ). The function is the logic that should do the check in order to see if the condition is satisfied. Then, there is the Input value that contains the gameObject that called the condition so that you can perform some check even related to the caller itself. In the example below “_weeke” is the key, “Date/IsWeekEnd” is the inspector name and then there are two comparisons of \"DayOfWeek\"."
  },
  "manual/Custom Events.html": {
    "href": "manual/Custom Events.html",
    "title": "Custom Events | Copyright © 2021 ATStudio",
    "keywords": "Custom Events For all the events not handled natively in Surfer, we can use CustomEvents : events that we send to Surfer in order to let SUElement handle them. Animator An example of custom events can be done with the Animator . Basically : let's add the component SUAnimatorBehaviour to an animator state machine select if the behavior should run on the Animator State Enter or Exit mode create an action SendCustomEvent and choose an event from the dropdown list add SUElement to whatever scene object and , as event , select MyCustomEvent and then choose the event name chosen in the step above Now , you can react to an Animator State Enter or Exit event as you wish. LeanTouch An example of custom events can even be LeanTouch . Basically : let's add the component LeanFingerTap to a scene object let's add to the same object the component SUAction : now create a SendCustomEvent action and choose an event from the dropdown list in the public event OnWorld of LeanFingerTap , drag the SUAction component in it and select the Play method add SUElement to whatever scene object and , as event , select MyCustomEvent and then choose the event name chosen in the step 2 Now , you can react to a LeanTouch event as you wish."
  },
  "manual/Custom Reactions.html": {
    "href": "manual/Custom Reactions.html",
    "title": "Custom Reactions | Copyright © 2021 ATStudio",
    "keywords": "Custom Reactions Let’s see how we can add Custom reactions to the inspector list of the SUElement . What we have to do is to open the script CustomReactions that we can find in the Element folder. Then we must simply add a new entry to the dictionary called “All”. The KeyValuePair entry is structured in this way : Key : is a string use to identify the condition in the inspector (if you change it , all the references in all the inspector will be lost) Value : is a combination of a string and an action. The string is the name/path of the reaction that you will see written in the Inspector ( you can change it as many times as you want ). The action is the logic that it will be performed. Then, there is the Input value that contains the gameObject that called the reaction so that you can perform some logic even related to the caller itself."
  },
  "manual/Edit states and events.html": {
    "href": "manual/Edit states and events.html",
    "title": "Edit states and events | Copyright © 2021 ATStudio",
    "keywords": "Edit states and events Let’s see how we can rename , add or delete a state name or a custom event name . What we have to do is to go to Unity->Preferences and select Surfer . Here we are able to manage all our state and custom events name."
  },
  "manual/First Conditions Panel.html": {
    "href": "manual/First Conditions Panel.html",
    "title": "First Condition Panel | Copyright © 2021 ATStudio",
    "keywords": "First Condition Panel What if we want to show, as first panel , the Menu one only when a specific condition is satisfied and another panel when another condition if satisfied? For this scenario, we can simply use Conditions . Surfer has two type of conditions : Custom (with programmer's code) and Fast (built-in Unity API shortcuts). We’ll use Fast in this example. Setup Let's setup everything : add SUElement to a random scene object create a MySceneLoaded event add the Fast condition Application/IsLanguage and choose English add under the If Conditions True tab of the DO... section, a Surfer Action that will open a Menu panel add under the If Conditions False tab of the DO... section, a Surfer Action that will open a Settings panel Like this: Then, always in our scene Canvas : let's create two panels with two SUElement states set to Menu and Settings each other let's add to each one of them , the fast reaction called SetAnchoredPosition under the State/MyStateEnter event ( see Scene First Panel ) Move the panels out of Camera view and hit play. Surfer will show the Menu panel if our computer is set to \"English language\" and the Settings panel if not ."
  },
  "manual/Focus... and remember.html": {
    "href": "manual/Focus... and remember.html",
    "title": "Focus ... and remember | Copyright © 2021 ATStudio",
    "keywords": "Focus ... and remember When we open a UI Panel , we would like to Focus on/Select a particular UI object ( especially a button ) or maybe the last selected UI element of the panel itself. In Surfer, to accomplish this, we must simply use UIGenerics/FocusOnObjectOrStateLast and drag the object we want to “Focus on” when the state is open and when the state has no \"last selected object\" in its focus history. This approach is useful especially for normal Menus. For example : At game launch, we open the Menu and because it has no history focus , the panel will focus on the Play button. Then we select the Settings button and we open the Settings panel Then we go back from Settings panel to Menu panel and now, because the panel has history focus, it will \"Select/Focus\" the Settings button instead of the Play button."
  },
  "manual/Focus.html": {
    "href": "manual/Focus.html",
    "title": "Focus | Copyright © 2021 ATStudio",
    "keywords": "Focus When we open a UI Panel , we would like to Focus on/Select a particular UI Element, especially a button. In Surfer, to accomplish this, we must simply use UIGenerics/FocusOnObject and drag the object we want to “Focus on” when the state is open. So, if we hit play, when the UI state of that button will be open, we will see that button being automatically selected and coloured/animated/sprite swapped based on the settings of its Selectable component (in this case coloured of red) This approach is useful especially for Popups, where the focus should always be on the same UI button."
  },
  "manual/Generating Constants.html": {
    "href": "manual/Generating Constants.html",
    "title": "Generating Constants | Copyright © 2021 ATStudio",
    "keywords": "Generating Constants If we use Surfer at runtime , when listening/registering to events, we should add string-based parameters representing the names of the states or scenes. To avoid using strings , we can generate Constants by going to Unity->Preferences->Surfer and clicking the button Generate Constants : a class SUConsts will be created that will allow you to access and use all scenes, states and custom events names without using strings."
  },
  "manual/GroupState.html": {
    "href": "manual/GroupState.html",
    "title": "Group States | Copyright © 2021 ATStudio",
    "keywords": "Group States The SUGroupStateUI component is responsible for automatically moving in and moving out ( with an animation ) all its children states , by centering the one currently open . So, assuming we have a group object with two children states , like in this image... ... when calling OpenState Menu, the group will slowly move the Menu panel at the center and when calling OpenState Settings , it will do the opposite."
  },
  "manual/History focus.html": {
    "href": "manual/History focus.html",
    "title": "History Focus | Copyright © 2021 ATStudio",
    "keywords": "History Focus The History Focus feature of Surfer let's you \"highlight\" the selected button of a previosu state that led to the opening of a new one . For example : we have a panel that contains 3 buttons ( Play,Settings,About ) and then a popup. The moment we click About and we open the popup , the button About receives the callback as \"last selected object\" of a previous state and it changes its appearance based on our preferences so that the user can visually see which was the last clicked button. In order to let an object receive this callback, we must simply react ( always in a SUElement component ) to the event UIGeneric/OnBecomeLastStateSelection ."
  },
  "manual/Input.html": {
    "href": "manual/Input.html",
    "title": "Input Integration | Copyright © 2021 ATStudio",
    "keywords": "Input Integration First of all, in Unity->Preferences->Surfer we can select the current input system we are using. Then, let's select Save and Recompile and wait Unity to recompile. If we are using LeanTouch , the integration comes with the use of CustomEvents , see here Back Button Let’s setup a “Back button”, an action that will happen without clicking a specific UI element and only when that state is open. To do this, the event to use is : Input/OldInput/OnKeyDown for the Old Input System Input/NewInput/OnAction for the New Input System Input/Rewired/OnAction for Rewired Next, let's choose the input key that will trigger the action. Finally, in the If... section ( category Fast! ) let's choose State/IsMyStateOpen : this condition will make sure that the input action will be performed only when the state of the object where the component SUElement has been added on, is open; without this condition the input action will be always triggered. Now, let's add the CloseMyState action mode in the DO... -> If Conditons True section. What we have setup is a stated input, useful for Back buttons or whatever type of input actions that do not require UI elements to be clicked and that are performed only when the parent state is open."
  },
  "manual/Installation.html": {
    "href": "manual/Installation.html",
    "title": "Installation | Copyright © 2021 ATStudio",
    "keywords": "Installation First of all, the usage of Surfer requires the free tweening asset called DOTween available here Once you have downloaded and setup DOTween, go to Tools->Surfer and select “Install or Update” : Surfer will automatically install or update itself (this action has to be done every time you download a new version of Surfer) Now you can start using Surfer. DISCLAIMER : All the scripts not used in this guides should NOT be used; they’re part of a migration/deprecation process"
  },
  "manual/Loading Scene Progress.html": {
    "href": "manual/Loading Scene Progress.html",
    "title": "Loading Scene Progress | Copyright © 2021 ATStudio",
    "keywords": "Loading Scene Progress In order to show a progress bar with a progress text during the loading of a scene, we must simply use these two types of SUElement : Loading_Text : if we want to show the progress of a scene on a TextMeshPro text Loading_Image : if we want to fill an Image based on the progress of the scene ( the Image component should be of Filled type ) Automatically, Surfer will update all these elements when an async scene loading is performed ."
  },
  "manual/Local Multiplayer and PlayerID.html": {
    "href": "manual/Local Multiplayer and PlayerID.html",
    "title": "Local Multiplayer and PlayerID | Copyright © 2021 ATStudio",
    "keywords": "Local Multiplayer and PlayerID If we're dealing with a local multiplayer game , then we can use a really handy Surfer feature that will help us managing states and panel of different players as well as their EventSystem. This feature is the PlayerID . Basically, when we setup a state in our SUElement component we can see a field called Player ID : this value is accountable for handling multiple independent player UI states for a local multiplayer game. For example , if we have a 2P Local Multiplayer game with two equal state panels called Menu and two EventSystems ( or MultiplayerEventSystems ) in the scene : we set the PlayerID of the first Menu to 1 and the PlayerID of the second Menu to 2 we add to the name of an EventSystem the word 1P and to the name of the other one 2P In this way Surfer will be able to link every player state to its corresponding EventSystem. The value of the player id field has a special meaning when set to -1 , like the table shows : Value Description -1 The player ID is inherited from the parent object ( Example : if Menu state has playerID 1 , all its substates with playerID -1 will automatically change to 1 at runtime ) . If no parent found , is equal to 0. Not -1 No special use. It will be used the number specified. EventSystem Runtime By default, when we manually select by code an UI object we normally use EventSystem.current.SetSelectedGameObject(myObject) . Instead , we must let Surfer do the job and use the SurferManager.I.FocusOnObject call that will automatically check the playerID of the UI object and handle everything."
  },
  "manual/Migration v1 to v2.html": {
    "href": "manual/Migration v1 to v2.html",
    "title": "Migration v1 to v2 | Copyright © 2021 ATStudio",
    "keywords": "Migration v1 to v2 The version 2.0 of Surfer has brought lot of changes that requires ( for those that had downloaded Surfer v1 ) a “soft” migration in order to work. Soft migration means that all the old scripts will continue to work even in v2 , but you must update your Surfer logic before v2.5, version that will completely deprecate the old scripts. So, first of all, after downloading the new v2 , you will see some errors related to the script ConditionChecks . Basically, open the ConditionChecks script and every time you encounter ()=> change it to (input)=> . Save the file and you’ll be fine. Finally, in the v2 everything is around the SUElement component, so follow all the guides in the Manual section to see how the component should be used in order to substitute the old logic in v1. For any questions or problem, send us an email with subject Migration"
  },
  "manual/Mouse Cursor .html": {
    "href": "manual/Mouse Cursor .html",
    "title": "Mouse Cursor | Copyright © 2021 ATStudio",
    "keywords": "Mouse Cursor When we hover with a mouse on a clickable or specific UI element , sometimes we would like to show a different mouse cursor icon than the default one. To do this, we must simply let the SUElement react to the event UIGenerics/OnEnter or UIGenerics/OnExit and choose the fast reactions Cursor/SetIcon or Cursor/SetIconCentered to change the image of the cursor. If you want to go back to the default one , use Cursor/SetDefaultIcon ."
  },
  "manual/Mouse Hover Selection.html": {
    "href": "manual/Mouse Hover Selection.html",
    "title": "Mouse Hover Selection | Copyright © 2021 ATStudio",
    "keywords": "Mouse Hover Selection By default, when you hover on an object with the mouse, Unity won't select the UI element but will only highlight it. If you want the UI element to be selected and deselected on \"MouseEnter\" and \"MouseExit\", just add the SUElement and the Selectable component ( or one that inherits from it like the Button one) to the UI object itself and Surfer will handle all by itself. WARNING : An element hovered but without the SUElement component , won't be tracked in some Surfer mechanics like the HistoryFocus. It is recommended to use the component if we are going to use a mouse."
  },
  "manual/Notification and Stack.html": {
    "href": "manual/Notification and Stack.html",
    "title": "Notification and Stack | Copyright © 2021 ATStudio",
    "keywords": "Notification and Stack To create a Notification state panel , namely a panel that closes itself, we must simply set as CloseMode the value Myself and set a Delay after which the state will automatically close. The in and out animations are not automatically set but we should , as always , react to the events MyStateEnter and MyStateExit and setup whatever animation we want from the reaction list called Animated! . Stack When we open a specific state, if it is already opened , the call will be discarded; this is inconvenient for a notification panel. To stack all the \"Opening Calls\" we must check the value IsStackable in the SUElement component. Then we must event set the StackDelay value : this value should be HIGHER than the total duration of the MyStateExit animations , otherwise the state will instantly close and reopen itself when the previous closing animations have not finished yet."
  },
  "manual/Playmaker.html": {
    "href": "manual/Playmaker.html",
    "title": "PlayMaker | Copyright © 2021 ATStudio",
    "keywords": "PlayMaker Let’s see how to use a Surfer Action with PlayMaker . First of all, unpack PlayMaker integration from Tools->Surfer->PlayMaker->Unpack Surfer has only one action for PlayMaker and it’s called TriggerAction . With this action you can run standard Surfer operations like opening a state, a scene , etc… Event Listener To receive a State or Scene Event we must : add the component SUStateEvent or SUSceneEvent to the scene object that should receive it send a PlayMaker Event directly from their UnityEvents in the inspector Then, in our PlayMaker window , we register to the event as usual"
  },
  "manual/Position Animation.html": {
    "href": "manual/Position Animation.html",
    "title": "Position Animation | Copyright © 2021 ATStudio",
    "keywords": "Position Animation In the list of animated reactions ( SUElement->Do...->Animated! ) there is an animation called Position . Basically, if we want to simply animate an anchoredPosition of an UI object, we must use the AnchoredPosition animation, but if we don't want to deal with specific values and just use percentages based , we must use the one called Position . The percentages that we see ( To Parent % and To Size % ) are related to the size of the parent RectTransform of the object animated and the size of the RectTransform animated. Below some examples by using a button inside a parent Rect Transform."
  },
  "manual/Runtime Events.html": {
    "href": "manual/Runtime Events.html",
    "title": "Runtime events | Copyright © 2021 ATStudio",
    "keywords": "Runtime events Let’s see how we can easily register to specific state/scene events by code, so that we can run our custom class logic. First, let’s create a class called, for example, MyTest. After, let’s add using Surfer; at the top, so that we can access its namespace. Next, let’s declare the interface ISUStateEnterHandler and implement its method OnSUStateEnter. Then, in the Awake (or wherever we want), we must register the class as receiver of that event , by passing all the states we want to receive the callback . Like this: To unregister use UnregisterStateEnter method and pass the same states as parameters. The same we can do for a scene event, like implementing the interface ISUSceneLoadedHandler or ISUSceneUnloadedHandler and calling their corresponding register methods."
  },
  "manual/Scene First Panel.html": {
    "href": "manual/Scene First Panel.html",
    "title": "Scene First Panel | Copyright © 2021 ATStudio",
    "keywords": "Scene First Panel Let's see how to trigger the opening of a panel when a Scene is loaded. Setup Assuming we have a scene with a Canvas and a Camera, let’s add the component SUElement to the Camera. Now, click + to add a new event and in the WHEN… section select Scene/MySceneLoaded as event. Next, in order to open a panel (UI State), we must create a Surfer Action . Basically, in the If Conditions True tab of the DO… section , let’s add a new item to the Surfer’s Actions list and as Mode let’s select OpenState and as state let’s select Menu . When editing a list of actions, sometimes you could see some strange behaviours to the inspector list items. So, fold all the actions you are not editing and edit only the one you want to Now, in our scene Canvas, let's create a UI Panel, let’s add the component SUElement to it , set the Type to State and set the State to Menu Then, add a State/MyStateEnter event and in the DO… section let’s add a fast reaction called SetAnchoredPosition and set the values to 0 ( this reaction is not mandatory , it's only for example purposes, you can choose the one it's better for you ) As last thing, move your UI Panel out of Camera view, hit play and what you will see is the same panel being shown directly in front of the Camera!"
  },
  "manual/Selection Indicator.html": {
    "href": "manual/Selection Indicator.html",
    "title": "Selection Indicator | Copyright © 2021 ATStudio",
    "keywords": "Selection Indicator A Selection Indicator is a type of UI element that is used to \"indicate\", with or without an animation, the current selected object of a UI Canvas. Here's what to do to add one : drag into a scene the SUPersistentCanvas prefab that you can find in the Prefab folder of Surfer then drag the prefab Arrows ( available in the Prefab/SelectionIndicators folder ) under the object Canvas of the prefab created above , and set 0 as playerID create a SUElement menu panel state ( with a button inside ) and set 0 as playerID of the state add , in the same panel, a MonoBehaviour/Awake event with a UIGenerics/FocusOnObject fast reaction and put the button created in the available reaction's field Like this Hit play and we'll see the two arrows of our prefab indicating the button of the menu. Extra Normally, the prefab SUPersistentCanvas should be added only to the first scene of a game, like the Splash screen. This object will then persist through all the scenes. If you want to use a different indicator for a 2nd player, just duplicate the object Canvas under SUPersistentCanvas/SelectionIndicators , then change the Indicator prefab inside the Canvas and change the playerID of the Indicator accordingly If you want to use a scale animation on a SelectionIndicator element , you should NOT run the scale animation on the element itself but you should create an empty child , put all your UI objects in it, and then run the scale animation on this child. That's because the logic of a SelectionIndicator uses the scale values and every scale animation on the object itself will break the entire logic ( see prefab Corners in Prefab/Indicators folder as scale example )"
  },
  "manual/Sibling Delay.html": {
    "href": "manual/Sibling Delay.html",
    "title": "Sibling Delay | Copyright © 2021 ATStudio",
    "keywords": "Sibling Delay When dealing with Animated! reactions sometimes we would like to start the animations of the game objects with a delay based on the hierarchy , like a particular sequence. All the Surfer inspector animations have 3 types of delay : Normal : the delay will be the one specified in the inspector WithSiblingIndex : the delay will be multiplied by the sibling index of the object ( meaning that the sibling 0 will start immediately the animation ) WithSiblingIndex : the delay will be multiplied by the sibling index of the object plus 1 ( meaning that the sibling indexes won't start at 0 but 1 ) This is particularly useful for menu buttons that needs to show up with a little bit of delay between each one of them."
  },
  "manual/SideMenu Drag.html": {
    "href": "manual/SideMenu Drag.html",
    "title": "SideMenu Drag | Copyright © 2021 ATStudio",
    "keywords": "SideMenu Drag In order to create a panel that can be opened or closed by dragging it, we must choose as type of SUElement an option between DragLeft_State , DragRight_State , DragUp_State or DragDown_State : it depends on which direction your panel is facing to . Basically the Drag State : depends on its current position depends on the parent RectTransform size and position uses the \"extruding\" part of it as part that should be dragged uses a threshold of 50% a drag limit of opening and closing doesn't work if rotated In the Demo folder of Surfer , you can find an example scene of how it works."
  },
  "manual/Sprite or Mesh.html": {
    "href": "manual/Sprite or Mesh.html",
    "title": "Sprite or Mesh? | Copyright © 2021 ATStudio",
    "keywords": "Sprite or Mesh? Sometimes we deal with sprites or meshes inside a Canvas. When using a SUElement component on these types of objects, in order to receive UIGenerics events we must check the field Is Sprite or Mesh . INFO : This value runs a logic that will check/add components like GraphicsRaycaster and Collider . So , if the expected UI events are not working, it is probably due to a conflict of the components with your current UI logic."
  },
  "manual/Tooltip.html": {
    "href": "manual/Tooltip.html",
    "title": "Tooltip | Copyright © 2021 ATStudio",
    "keywords": "Tooltip To show a tooltip on mouse over , we must simply set the type of a SUElement to Tooltip_State and then call OpenState as usual. The field Offset Factor is a value that decides the distance of the Tooltip state from the mouse cursor : negative values bring the tooltip at a left-bottom position relative to the cursor . Finally, the tooltip will always stay automatically in the Camera rect and will never go out of it : by default the position relative to the mouse is top-right ."
  },
  "manual/Tutorial Click Constraint.html": {
    "href": "manual/Tutorial Click Constraint.html",
    "title": "Tutorial Click Constraint | Copyright © 2021 ATStudio",
    "keywords": "Tutorial Click Constraint In order to create a Tutorial panel where only a specific button can be clicked , we must simply choose the fast reaction UIGenerics/EnableClickConstraint . Basically : we call OpenState for a state panel Tutorial on the MyStateEnter event of the same panel, we choose UIGenerics/EnableClickConstraint as fast reaction and we drag the button we want to enable the constraint on To disable the constraint and allow click on the entire panel, the fast reaction UIGenerics/EnableClickConstraint should be used. INFO : This fast reaction uses CanvasGroup components in order to work. So , if the expected constraint is not working, it is probably due to a conflict of the components with your current UI logic. Ideal Use In a normal ideal UI flow, the constraint click won't be used directly in a Tutorial state panel but directly on game panel like Menu or Settings because of the fact that the button will probably be part of these UI states. Basically, let's say for example that we have a Menu state panel and that, at first app launch ever, we want the user to click on the first button of this state ; what we will do is : call OpenState for the state Menu , using a specific version like 5 the Menu state will handle the MyStateEnter event with version 5 and will enable the constrain on the first button the users clicks on that button and we call OpenState for the state Menu , using version 1 now, the Menu state will handle the MyStateEnter event with version 1 and will disable all the constraints . Therefore the tutorial has ended and the Menu \"will act normally\""
  },
  "manual/Versions.html": {
    "href": "manual/Versions.html",
    "title": "Versions | Copyright © 2021 ATStudio",
    "keywords": "Versions Every time we perform a Surfer Action like OpenState or CloseState, we can see a field called Version . This value let's you handle in different ways the same panel. For example : we have a Notification panel state called Info when the player receives a friend request we call OpenState -> Info and we set the version to 1 the Info panel, receives the MyStateEnter event with version number 1, and decides to set the icon and text for the \"Friend Request\" notification then , when the player unlock an achievement we call OpenState -> Info and we set the version to 2 the Info panel, receives the MyStateEnter event with version number 2, and decides to set the icon and text for the \"Achievement Unlock\" notification This is what versions are made for : reusing the same state and handling it based the version number. Version 0 The moment we set the version to 0 , we are actually using a number that uses a \"special logic\": we are actually handling \"All versions\". Number Description 0 By setting 0, all versions will be called/opened/handled. If a state manages versions 1 and 2, the logic of both versions will run. Not 0 Only the specified version will be called/opened/handled by the state REMEMBER : If you open a state using version 1 and that state is already open with version 0 , the opening call will be discarded. The same goes for trying to close a state using version 1 when the same state with version 0 is open. Most of the times the \"closing call\" should be performed by using version 0. In the Demo folder of Surfer , you can find an example scene of how it works with a popup."
  }
}